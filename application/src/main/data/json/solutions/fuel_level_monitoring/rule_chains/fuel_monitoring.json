{
  "ruleChain": {
    "additionalInfo": {
      "description": ""
    },
    "name": "Fuel Monitoring",
    "type": "CORE",
    "firstRuleNodeId": null,
    "root": false,
    "debugMode": false,
    "configuration": null,
    "externalId": null
  },
  "metadata": {
    "firstNodeIndex": 14,
    "nodes": [
      {
        "additionalInfo": {
          "description": null,
          "layoutX": 1216,
          "layoutY": 372
        },
        "type": "org.thingsboard.rule.engine.telemetry.TbMsgTimeseriesNode",
        "name": "Save Timeseries",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "defaultTTL": 0
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "layoutX": 1217,
          "layoutY": 477
        },
        "type": "org.thingsboard.rule.engine.telemetry.TbMsgAttributesNode",
        "name": "Save Client Attributes",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scope": "CLIENT_SCOPE"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": null,
          "layoutX": 737,
          "layoutY": 489
        },
        "type": "org.thingsboard.rule.engine.filter.TbMsgTypeSwitchNode",
        "name": "Message Type Switch",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "version": 0
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "layoutX": 1216,
          "layoutY": 552
        },
        "type": "org.thingsboard.rule.engine.action.TbLogNode",
        "name": "Log RPC from Device",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scriptLang": "TBEL",
          "jsScript": "return '\\nIncoming message:\\n' + JSON.stringify(msg) + '\\nIncoming metadata:\\n' + JSON.stringify(metadata);",
          "tbelScript": "return '\\nIncoming message:\\n' + JSON.stringify(msg) + '\\nIncoming metadata:\\n' + JSON.stringify(metadata);"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "layoutX": 1217,
          "layoutY": 617
        },
        "type": "org.thingsboard.rule.engine.action.TbLogNode",
        "name": "Log Other",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scriptLang": "TBEL",
          "jsScript": "return '\\nIncoming message:\\n' + JSON.stringify(msg) + '\\nIncoming metadata:\\n' + JSON.stringify(metadata);",
          "tbelScript": "return '\\nIncoming message:\\n' + JSON.stringify(msg) + '\\nIncoming metadata:\\n' + JSON.stringify(metadata);"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "layoutX": 1216,
          "layoutY": 684
        },
        "type": "org.thingsboard.rule.engine.rpc.TbSendRPCRequestNode",
        "name": "RPC Call Request",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "timeoutInSeconds": 60
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 374,
          "layoutY": 496
        },
        "type": "org.thingsboard.rule.engine.profile.TbDeviceProfileNode",
        "name": "Device Profile Node",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "persistAlarmRulesState": false,
          "fetchAlarmRulesStateOnStart": false
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 355,
          "layoutY": 682
        },
        "type": "org.thingsboard.rule.engine.analytics.latest.alarm.TbAlarmsCountNodeV2",
        "name": "Count alarms",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "alarmsCountMappings": [
            {
              "target": "lowBatteryAlarmsCount",
              "typesList": [
                "Low Battery Level"
              ],
              "severityList": [],
              "statusList": [
                "ACTIVE_UNACK",
                "ACTIVE_ACK"
              ]
            },
            {
              "target": "lowFuelLevelAlarmsCount",
              "typesList": [
                "Low Fuel Level"
              ],
              "severityList": [],
              "statusList": [
                "ACTIVE_UNACK",
                "ACTIVE_ACK"
              ]
            },
            {
              "target": "lowTemperatureAlarmsCount",
              "typesList": [
                "Low Temperature"
              ],
              "severityList": [],
              "statusList": [
                "ACTIVE_UNACK",
                "ACTIVE_ACK"
              ]
            },
            {
              "target": "highTemperatureAlarmsCount",
              "typesList": [
                "High Temperature"
              ],
              "severityList": [],
              "statusList": [
                "ACTIVE_UNACK",
                "ACTIVE_ACK"
              ]
            }
          ],
          "countAlarmsForPropagationEntities": false,
          "propagationEntityTypes": null,
          "outMsgType": "POST_TELEMETRY_REQUEST",
          "queueName": null
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 737,
          "layoutY": 787
        },
        "type": "org.thingsboard.rule.engine.transform.TbTransformMsgNode",
        "name": "To Active Telemetry",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scriptLang": "TBEL",
          "jsScript": "\nif (msgType === \"POST_TELEMETRY_REQUEST\") {\n    msg.isLowBattery = msg.lowBatteryAlarmsCount > 0 ? true : false;\n    msg.isLowFuel = msg.lowFuelLevelAlarmsCount > 0 ? true : false;\n    msg.isLowTemperature = msg.lowTemperatureAlarmsCount > 0 ? true : false;\n    msg.isHighTemperature = msg.highTemperatureAlarmsCount > 0 ? true : false;\n    msg.isNoAlarms = (!msg.isLowBattery && !msg.isLowFuel && !msg.isLowTemperature && !msg.isHighTemperature);\n} else {\n    msg.isLowBattery = metadata.ss_lowBatteryAlarmsCount > 0 ? true : false;\n    msg.isLowFuel = metadata.ss_lowFuelLevelAlarmsCount > 0 ? true : false;\n    msg.isLowTemperature = metadata.ss_lowTemperatureAlarmsCount > 0 ? true : false;\n    msg.isHighTemperature = metadata.ss_highTemperatureAlarmsCount > 0 ? true : false;\n    msg.isNoAlarms = (!metadata.isLowBattery && !metadata.isLowFuel && !metadata.isLowTemperature && !metadata.isHighTemperature);\n}\n\nvar alarmFilter = \"\";\n\nif (\n    (metadata.ss_active === false || metadata.ss_active === \"false\") || \n    (msg.active === false || msg.active === \"false\")\n   ) {\n    alarmFilter += \"offline \";\n}\n\nif (msg.isLowBattery || metadata.isLowBattery) {\n    alarmFilter += \"lowBattery \";\n}\n\nif (msg.isLowFuel || metadata.isLowFuel) {\n    alarmFilter += \"lowFuel \";\n}\n\nif (msg.isLowTemperature || metadata.isLowTemperature) {\n   alarmFilter += \"lowTemperature \"; \n}\n\nif (msg.isHighTemperature || metadata.isHighTemperature) {\n    alarmFilter += \"highTemperature \";\n}\n\nif (msg.isNoAlarms || metadata.isNoAlarms) {\n    alarmFilter += \"noAlarms \";\n}\n\nmsg.alarmFilter = alarmFilter;\n\nreturn {msg: msg, metadata: metadata, msgType: \"POST_ATTRIBUTES_REQUEST\"};",
          "tbelScript": "var active;\n\nif (msgType == \"POST_TELEMETRY_REQUEST\") {\n    msg.isLowBattery = msg.lowBatteryAlarmsCount > 0 ? true : false;\n    msg.isLowFuel = msg.lowFuelLevelAlarmsCount > 0 ? true : false;\n    msg.isLowTemperature = msg.lowTemperatureAlarmsCount > 0 ? true : false;\n    msg.isHighTemperature = msg.highTemperatureAlarmsCount > 0 ? true : false;\n    msg.isNoAlarms = (!msg.isLowBattery && !msg.isLowFuel && !msg.isLowTemperature && !msg.isHighTemperature);\n    active = (metadata.ss_active != null && (metadata.ss_active == false || metadata.ss_active == \"false\")) ? false : true;\n} else {\n    msg.isLowBattery = metadata.ss_lowBatteryAlarmsCount > 0 ? true : false;\n    msg.isLowFuel = metadata.ss_lowFuelLevelAlarmsCount > 0 ? true : false;\n    msg.isLowTemperature = metadata.ss_lowTemperatureAlarmsCount > 0 ? true : false;\n    msg.isHighTemperature = metadata.ss_highTemperatureAlarmsCount > 0 ? true : false;\n    msg.isNoAlarms = (!msg.isLowBattery && !msg.isLowFuel && !msg.isLowTemperature && !msg.isHighTemperature);\n    active = (msg.active != null && (msg.active == false || msg.active == \"false\")) ? false : true;\n}\n\nvar alarmFilter = \"\";\n\nif (active == false) {\n    alarmFilter += \"offline \";\n}\n\nif (msg.isLowBattery) {\n    alarmFilter += \"lowBattery \";\n}\n\nif (msg.isLowFuel) {\n    alarmFilter += \"lowFuel \";\n}\n\nif (msg.isLowTemperature) {\n   alarmFilter += \"lowTemperature \"; \n}\n\nif (msg.isHighTemperature) {\n    alarmFilter += \"highTemperature \";\n}\n\nif (msg.isNoAlarms) {\n    alarmFilter += \"noAlarms \";\n}\n\nmsg.alarmFilter = alarmFilter;\n\nreturn {msg: msg, metadata: metadata, msgType: \"POST_ATTRIBUTES_REQUEST\"};"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 1217,
          "layoutY": 786
        },
        "type": "org.thingsboard.rule.engine.telemetry.TbMsgAttributesNode",
        "name": "Save",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scope": "SERVER_SCOPE",
          "notifyDevice": false,
          "sendAttributesUpdatedNotification": false
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 358,
          "layoutY": 787
        },
        "type": "org.thingsboard.rule.engine.metadata.TbGetAttributesNode",
        "name": "Add active metadata",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "tellFailureIfAbsent": false,
          "fetchToData": false,
          "clientAttributeNames": [],
          "sharedAttributeNames": [],
          "serverAttributeNames": [
            "active"
          ],
          "latestTsKeyNames": [],
          "getLatestValueWithTs": false
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 737,
          "layoutY": 691
        },
        "type": "org.thingsboard.rule.engine.metadata.TbGetAttributesNode",
        "name": "Get alarms count attributes",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "tellFailureIfAbsent": false,
          "fetchToData": false,
          "clientAttributeNames": [],
          "sharedAttributeNames": [],
          "serverAttributeNames": [
            "highTemperatureAlarmsCount",
            "lowBatteryAlarmsCount",
            "lowFuelLevelAlarmsCount",
            "lowTemperatureAlarmsCount"
          ],
          "latestTsKeyNames": [],
          "getLatestValueWithTs": false
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 724,
          "layoutY": 270
        },
        "type": "org.thingsboard.rule.engine.metadata.TbGetAttributesNode",
        "name": "Get tank shape params",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "tellFailureIfAbsent": false,
          "fetchToData": false,
          "clientAttributeNames": [],
          "sharedAttributeNames": [],
          "serverAttributeNames": [
            "sizeMeasure",
            "tankShape",
            "tankCapacity",
            "tankDimensionUnits",
            "sensorGap",
            "tankCapacityOutput",
            "sensorDimensionUnits",
            "tankMeasurementSystem",
            "sensorMeasurementSystem",
            "levelMeasurement"
          ],
          "latestTsKeyNames": [],
          "getLatestValueWithTs": false
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 729,
          "layoutY": 378
        },
        "type": "org.thingsboard.rule.engine.transform.TbTransformMsgNode",
        "name": "Calculate fuelLevel",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "scriptLang": "TBEL",
          "jsScript": "var sizeMeasure = JSON.parse(metadata.ss_sizeMeasure);\nvar tankCapacity = Number(metadata.ss_tankCapacity);\nvar tankMeasurementSystem = metadata.ss_tankMeasurementSystem;\nvar tankDimensionUnits = metadata.ss_tankDimensionUnits;\nvar sensorGap = Number(metadata.ss_sensorGap);\nvar tankCapacityOutput = metadata.ss_tankCapacityOutput;\nvar sensorMeasurementSystem = metadata.ss_sensorMeasurementSystem;\nvar sensorDimensionUnits = metadata.ss_sensorDimensionUnits;\nvar fuelLevel;\nvar volume;\n\nvar imperial = {\n    dimension: {\n        inches: \"in\",\n        feets: \"ft\"\n    },\n    output: {\n        gallons: \"Gal\",\n        cubicIn: \"in^3\",\n        cubicFt: \"ft^3\"\n    }\n};\n\nvar metric = {\n    dimension: {\n        milimeters: \"mm\",\n        centimeters: \"cm\",\n        meters: \"m\"\n    },\n    output: {\n        liters: \"L\",\n        cubicMm: \"mm^3\",\n        cubicCm: \"cm^3\",\n        cubicM: \"m^3\"\n    }\n};\n\nvar absoluteSensorHeight = convertInput(msg.fuelHeight, sensorDimensionUnits) - convertInput(sensorGap, tankDimensionUnits);\nvar h;\nvar d;\nvar l;\nvar w;\nvar θ;\nvar m;\nvar capacitySegment;\n\nswitch (metadata.ss_tankShape) {\n    case \"Vertical Cylinder\": \n        h = absoluteSensorHeight;\n        d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n\n        volume = convertOutput(((Math.PI * Math.pow((d / 2), 2) * h) / 1000));\n        break;\n        \n    case \"Horizontal Cylinder\":\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n        m = (d / 2) - (d - absoluteSensorHeight);\n        θ = 2 * Math.acos(m / (d / 2));\n        \n        volume = tankCapacity - convertOutput(((Math.pow((d / 2), 2) * (θ - Math.sin(θ)) * l) / 2) / 1000);\n        break;\n        \n    case \"Rectangle\":\n        h = absoluteSensorHeight;\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        w = convertInput(sizeMeasure.width, tankDimensionUnits);\n\n        volume = convertOutput(((h * l * w) / 1000));\n        break;\n        \n    case \"Horizontal Oval\":\n        h = convertInput(sizeMeasure.height, tankDimensionUnits);\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        w = convertInput(sizeMeasure.width, tankDimensionUnits);\n        \n        // w>h must always be true\n        \n        var horizontalCylinderPartCapacity = (Math.PI * Math.pow((h / 2), 2) * l);\n        m = (h / 2) - (h - absoluteSensorHeight);\n        θ = 2 * Math.acos(m / (h / 2));\n        var horizontalCylinderPartSegment = ((Math.pow((h / 2), 2) * (θ - Math.sin(θ)) * l) / 2);\n        var filledVolumeOfHorizontalCylinderPart = horizontalCylinderPartCapacity - horizontalCylinderPartSegment;\n        var filledVolumeOfRectanglePart = absoluteSensorHeight * l * (w - h);\n        volume = convertOutput((filledVolumeOfRectanglePart + filledVolumeOfHorizontalCylinderPart)  / 1000);\n        break;\n        \n    case \"Vertical Oval\":\n        h = convertInput(sizeMeasure.height, tankDimensionUnits);\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        w = convertInput(sizeMeasure.width, tankDimensionUnits);\n        // h>w must always be true\n        \n        if (absoluteSensorHeight <= (w / 2)) {\n            m = (w / 2) - (w - absoluteSensorHeight);\n            θ = 2 * Math.acos(m / (w / 2));\n            \n            var horizontalPartCapacity = (Math.PI * Math.pow((w / 2), 2) * l);\n            volume = convertOutput((horizontalPartCapacity - ((Math.pow((w / 2), 2) * (θ - Math.sin(θ)) * l) / 2)) / 1000);\n        } else if (absoluteSensorHeight > (w / 2) && absoluteSensorHeight <= (w / 2 + (h - w))) {\n            var halfOfCylinderPortion = (Math.PI * Math.pow(w / 2, 2) * l) / 2;\n            var filledVolumeOfRectanglePart = (absoluteSensorHeight - (w / 2)) * l *  w;\n            volume = convertOutput((halfOfCylinderPortion + filledVolumeOfRectanglePart) / 1000);\n        } else if (absoluteSensorHeight > (w / 2 + (h - w)) && absoluteSensorHeight <= h) {\n            m = (w / 2) - (w - (absoluteSensorHeight - (h - w)));\n            θ = 2 * Math.acos(m / (w / 2));\n            \n            volume = tankCapacity - convertOutput(((Math.pow((w / 2), 2) * (θ - Math.sin(θ)) * l) / 2) / 1000);\n        }\n        \n        break;\n        \n    case \"Horizontal Capsule\":\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n        m = (d / 2) - (d - absoluteSensorHeight);\n        θ = 2 * Math.acos(m / (d / 2));\n        var horizontalCylinderCapacity = (Math.PI * Math.pow((d / 2), 2) * l);\n        var horizontalCylinderVolume = horizontalCylinderCapacity - ((Math.pow((d / 2), 2) * (θ - Math.sin(θ)) * l) / 2);\n                // var sphereCapacity = (4 / 3) * Math.PI * Math.pow((d / 2), 3) / 1000;\n        var sphereVolume = 1/3 * Math.PI * Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) - absoluteSensorHeight);\n        volume = convertOutput((horizontalCylinderVolume + sphereVolume) / 1000);\n        break;\n        \n    case \"Vertical Capsule\": \n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n                \n        if (absoluteSensorHeight <= (d / 2)) {\n            volume = convertOutput(1/3 * Math.PI * Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) -absoluteSensorHeight) / 1000);\n        } else if (absoluteSensorHeight > (d / 2) && absoluteSensorHeight <= (d / 2 + l)) {\n            var spherePortion = ((4/3) * Math.PI * Math.pow((d / 2), 3)) / 2;\n            var verticalCylinderPortion = (Math.PI * Math.pow((d / 2), 2) *\n                (absoluteSensorHeight - d / 2));\n            \n            volume = convertOutput((spherePortion + verticalCylinderPortion) / 1000);\n        } else if (absoluteSensorHeight > (d / 2 + l) && absoluteSensorHeight <= (l + d)) {\n            var spherePortion = 1/3 * Math.PI * Math.pow((absoluteSensorHeight - l), 2) * (3 * (d / 2) -\n                (absoluteSensorHeight - l));\n            var verticalCylinderCapacity = (Math.PI * Math.pow((d / 2), 2) * l);\n            \n            volume = convertOutput((spherePortion + verticalCylinderCapacity) / 1000);\n        }\n        break;\n        \n    case \"Horizontal 2:1 Elliptical\": \n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n        \n        θ = Math.acos((d / 2 - absoluteSensorHeight) / (d / 2));\n        var cylinderVolume = l * (Math.pow((d / 2), 2) * θ - ((d / 2) - absoluteSensorHeight) *\n            Math.sqrt(d * absoluteSensorHeight - Math.pow(absoluteSensorHeight, 2)));\n\n        var headsVolume = 0.2618 * Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) - absoluteSensorHeight) * 2;\n        volume = convertOutput((cylinderVolume + headsVolume) / 1000);\n        \n        break;\n    // Could not be verified based on the tests results (there is no way to check and verify the real results in web because formulas from different sources differ the result)\n    // case \"Horizontal Dish Ends\": \n    //     l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    //     d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n\n    //     // V = V_cylinder + V_spherical_heads\n\n    //     // Where:\n        \n    //     // V is the partial volume of the horizontal cylinder with spherical heads.\n    //     // V_cylinder = π * R^2 * (L - 2r) is the volume of the cylindrical portion.\n    //     // V_spherical_heads = (4/3) * π * r^3 is the volume of the two spherical heads.\n    //     // m = (d / 2) - (d - absoluteSensorHeight);\n    //     // θ = 2 * Math.acos(m / (d / 2));\n        \n    //     // volume = tankCapacity - convertOutput(((Math.pow((d / 2), 2) * (θ - Math.sin(θ)) * l) / 2) / 1000);\n    //     var z = d - l / ;\n    //     tankSegment = 1 / 3 * Math.PI\n        \n    \n    //     break;\n    case \"Horizontal Ellipse\": \n        h = convertInput(sizeMeasure.height, tankDimensionUnits);\n        l = convertInput(sizeMeasure.length, tankDimensionUnits);\n        w = convertInput(sizeMeasure.width, tankDimensionUnits);\n        \n        var ellipseSegment = (h * w / 4) * (Math.acos(1 - 2 * absoluteSensorHeight / h) -\n            (1 - 2 * absoluteSensorHeight / h) * Math.sqrt(4 * absoluteSensorHeight / h - 4 * Math.pow(absoluteSensorHeight, 2) / (h * h)));\n        volume = convertOutput((ellipseSegment * l) / 1000);\n        \n}\n\nfunction convertInput(value, dimensionUnits) {\n    switch (dimensionUnits) {\n        case imperial.dimension.inches:\n            return value * 2.54;\n        case imperial.dimension.feets:\n            return value * 30.48\n        case metric.dimension.milimeters:\n            return value / 10;\n        case metric.dimension.centimeters:\n            return value;\n        case metric.dimension.meters:\n            return value * 100;\n    }\n}\n    \nfunction convertOutput(value) {\n    switch (tankCapacityOutput) {\n        case imperial.output.gallons:\n            return value * 0.264172;\n        case imperial.output.cubicIn:\n            return value * 61.0237;\n        case imperial.output.cubicFt:\n            return value * 0.0353147;\n        case metric.output.liters:\n            return value;\n        case metric.output.cubicMm:\n            return value * 1000000;\n        case metric.output.cubicCm:\n            return value * 1000;\n        case metric.output.cubicM:\n            return value * 0.001;\n    }\n}\n\nfuelLevel = ((volume / tankCapacity) * 100).toFixed(0);\n\nmsg.fuelLevel = Number(fuelLevel);\n\nreturn {msg: msg, metadata: metadata, msgType: msgType};",
          "tbelScript": "var sizeMeasure = JSON.parse(metadata.ss_sizeMeasure);\nvar tankCapacity = parseFloat(metadata.ss_tankCapacity);\nvar tankMeasurementSystem = metadata.ss_tankMeasurementSystem;\nvar tankDimensionUnits = metadata.ss_tankDimensionUnits;\nvar sensorGap = metadata.ss_sensorGap != null ? parseFloat(metadata.ss_sensorGap) : null;\nvar tankCapacityOutput = metadata.ss_tankCapacityOutput;\nvar sensorMeasurementSystem = metadata.ss_sensorMeasurementSystem;\nvar sensorDimensionUnits = metadata.ss_sensorDimensionUnits;\nvar levelMeasurement = metadata.ss_levelMeasurement;\nvar fuelLevel;\nvar volume;\n\nvar imperial = {\n    \"dimension\": {\n        \"inches\": \"in\",\n        \"feets\": \"ft\"\n    },\n    \"output\": {\n        \"gallons\": \"Gal\",\n        \"cubicIn\": \"in^3\",\n        \"cubicFt\": \"ft^3\"\n    }\n};\n\nvar metric = {\n    \"dimension\": {\n        \"milimeters\": \"mm\",\n        \"centimeters\": \"cm\",\n        \"meters\": \"m\"\n    },\n    \"output\": {\n        \"liters\": \"L\",\n        \"cubicMm\": \"mm^3\",\n        \"cubicCm\": \"cm^3\",\n        \"cubicM\": \"m^3\"\n    }\n};\n\nvar levelMeasurements = {\n    \"empty\": \"Remaining space\",\n    \"full\": \"Fill height\"\n};\n\nvar tankShapes = {\n    \"vCylinder\": \"Vertical Cylinder\", \n    \"hCylinder\": \"Horizontal Cylinder\",\n    \"rectangle\": \"Rectangle\",\n    \"hOval\": \"Horizontal Oval\",\n    \"vOval\": \"Vertical Oval\",\n    \"hCapsule\": \"Horizontal Capsule\",\n    \"vCapsule\": \"Vertical Capsule\",\n    \"hElliptical\": \"Horizontal 2:1 Elliptical\",\n    \"hEllipse\": \"Horizontal Ellipse\"\n};\n\nvar absoluteSensorHeight;\nvar capacitySegment;\nvar height;\nvar h;\nvar d;\nvar l;\nvar w;\nvar θ;\nvar m;\n\nif (metadata.ss_tankShape == tankShapes.vCylinder) {\n    height = convertInput(sizeMeasure.height, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateVCylinder();\n    \n} else if (metadata.ss_tankShape == tankShapes.hCylinder) {\n    height = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateHCylinder();\n    \n} else if (metadata.ss_tankShape == tankShapes.rectangle) {\n    height = convertInput(sizeMeasure.height, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateRectangle();\n    \n} else if (metadata.ss_tankShape == tankShapes.hOval) {\n    height = convertInput(sizeMeasure.height, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateHOval();\n    \n} else if (metadata.ss_tankShape == tankShapes.vOval) {\n    height = convertInput(sizeMeasure.height, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateVOval();\n    \n} else if (metadata.ss_tankShape == tankShapes.hCapsule) {\n    height = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateHCapsule();\n    \n} else if (metadata.ss_tankShape == tankShapes.vCapsule) {\n    height = convertInput((sizeMeasure.diameter + sizeMeasure.length), tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateVCapsule();\n    \n} else if (metadata.ss_tankShape == tankShapes.hElliptical) {\n    height = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateHElliptical();\n    \n} else if (metadata.ss_tankShape == tankShapes.hEllipse) {\n    height = convertInput(sizeMeasure.height, tankDimensionUnits);\n    calculateAbsoluteHeight();\n    calculateHEllipse();\n}\n\nfunction calculateAbsoluteHeight() {\n    if (levelMeasurement == levelMeasurements[\"empty\"]) {\n        var diff = convertInput(msg.fuelHeight, sensorDimensionUnits) - convertInput(sensorGap, tankDimensionUnits);\n        \n        height = height > diff  ? height : diff;\n        absoluteSensorHeight = height - (convertInput(msg.fuelHeight, sensorDimensionUnits) - convertInput(sensorGap, tankDimensionUnits));\n    } else {\n        height = height > convertInput(msg.fuelHeight, sensorDimensionUnits)  ? height : convertInput(msg.fuelHeight, sensorDimensionUnits);\n        absoluteSensorHeight = convertInput(msg.fuelHeight, sensorDimensionUnits);\n    }\n}\n\nfunction calculateVCylinder() {\n    h = absoluteSensorHeight;\n    d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    \n    volume = convertOutput(((java.lang.Math.PI * java.lang.Math.pow((d / 2), 2) * h) / 1000));\n}\n\nfunction calculateHCylinder() {\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    m = (d / 2) - (d - absoluteSensorHeight);\n    θ = 2 * java.lang.Math.acos(m / (d / 2));\n    \n    volume = tankCapacity - convertOutput(((java.lang.Math.pow((d / 2), 2) * (θ - java.lang.Math.sin(θ)) * l) / 2) / 1000);\n}\n\nfunction calculateRectangle() {\n    h = absoluteSensorHeight;\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    w = convertInput(sizeMeasure.width, tankDimensionUnits);\n    \n    volume = convertOutput(((h * l * w) / 1000));\n}\n\nfunction calculateHOval() {\n    h = convertInput(sizeMeasure.height, tankDimensionUnits);\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    w = convertInput(sizeMeasure.width, tankDimensionUnits);\n    // w>h must always be true\n    \n    var horizontalCylinderPartCapacity = (java.lang.Math.PI * java.lang.Math.pow((h / 2), 2) * l);\n    m = (h / 2) - (h - absoluteSensorHeight);\n    θ = 2 * java.lang.Math.acos(m / (h / 2));\n    var horizontalCylinderPartSegment = ((java.lang.Math.pow((h / 2), 2) * (θ - java.lang.Math.sin(θ)) * l) / 2);\n    var filledVolumeOfHorizontalCylinderPart = horizontalCylinderPartCapacity - horizontalCylinderPartSegment;\n    var filledVolumeOfRectanglePart = absoluteSensorHeight * l * (w - h);\n    \n    volume = convertOutput((filledVolumeOfRectanglePart + filledVolumeOfHorizontalCylinderPart) / 1000);\n}\n\nfunction calculateVOval() {\n    h = convertInput(sizeMeasure.height, tankDimensionUnits);\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    w = convertInput(sizeMeasure.width, tankDimensionUnits);\n    // h>w must always be true\n    \n    if (absoluteSensorHeight <= (w / 2)) {\n        m = (w / 2) - (w - absoluteSensorHeight);\n        θ = 2 * java.lang.Math.acos(m / (w / 2));\n        var horizontalPartCapacity = (java.lang.Math.PI * java.lang.Math.pow((w / 2), 2) * l);\n        \n        volume = convertOutput((horizontalPartCapacity - ((java.lang.Math.pow((w / 2), 2) * (θ - java.lang.Math.sin(θ)) * l) / 2)) / 1000);\n    } else if (absoluteSensorHeight > (w / 2) && absoluteSensorHeight <= (w / 2 + (h - w))) {\n        var halfOfCylinderPortion = (java.lang.Math.PI * java.lang.Math.pow(w / 2, 2) * l) / 2;\n        var filledVolumeOfRectanglePart = (absoluteSensorHeight - (w / 2)) * l *  w;\n        \n        volume = convertOutput((halfOfCylinderPortion + filledVolumeOfRectanglePart) / 1000);\n    } else if (absoluteSensorHeight > (w / 2 + (h - w)) && absoluteSensorHeight <= h) {\n        m = (w / 2) - (w - (absoluteSensorHeight - (h - w)));\n        θ = 2 * java.lang.Math.acos(m / (w / 2));\n        \n        volume = tankCapacity - convertOutput(((java.lang.Math.pow((w / 2), 2) * (θ - java.lang.Math.sin(θ)) * l) / 2) / 1000);\n    }\n}\n\nfunction calculateHCapsule() {\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    m = (d / 2) - (d - absoluteSensorHeight);\n    θ = 2 * java.lang.Math.acos(m / (d / 2));\n    var horizontalCylinderCapacity = (java.lang.Math.PI * java.lang.Math.pow((d / 2), 2) * l);\n    var horizontalCylinderVolume = horizontalCylinderCapacity - ((java.lang.Math.pow((d / 2), 2) * (θ - java.lang.Math.sin(θ)) * l) / 2);\n    var sphereVolume = 1/3 * java.lang.Math.PI * java.lang.Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) - absoluteSensorHeight);\n    \n    volume = convertOutput((horizontalCylinderVolume + sphereVolume) / 1000);\n}\n\nfunction calculateVCapsule() {\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    \n    if (absoluteSensorHeight <= (d / 2)) {\n        volume = convertOutput(1/3 * java.lang.Math.PI * java.lang.Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) - absoluteSensorHeight) / 1000);\n    } else if (absoluteSensorHeight > (d / 2) && absoluteSensorHeight <= (d / 2 + l)) {\n        var spherePortion = ((4/3) * java.lang.Math.PI * java.lang.Math.pow((d / 2), 3)) / 2;\n        var verticalCylinderPortion = (java.lang.Math.PI * java.lang.Math.pow((d / 2), 2) *\n            (absoluteSensorHeight - d / 2));\n        \n        volume = convertOutput((spherePortion + verticalCylinderPortion) / 1000);\n    } else if (absoluteSensorHeight > (d / 2 + l) && absoluteSensorHeight <= (l + d)) {\n        var spherePortion = 1/3 * java.lang.Math.PI * java.lang.Math.pow((absoluteSensorHeight - l), 2) * (3 * (d / 2) -\n            (absoluteSensorHeight - l));\n            \n        var verticalCylinderCapacity = (java.lang.Math.PI * java.lang.Math.pow((d / 2), 2) * l);\n        \n        volume = convertOutput((spherePortion + verticalCylinderCapacity) / 1000);\n    }\n}\n\nfunction calculateHElliptical() {\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    d = convertInput(sizeMeasure.diameter, tankDimensionUnits);\n    θ = java.lang.Math.acos((d / 2 - absoluteSensorHeight) / (d / 2));\n    var cylinderVolume = l * (java.lang.Math.pow((d / 2), 2) * θ - ((d / 2) - absoluteSensorHeight) *\n        java.lang.Math.sqrt(d * absoluteSensorHeight - java.lang.Math.pow(absoluteSensorHeight, 2)));\n        \n    var headsVolume = 0.2618 * java.lang.Math.pow(absoluteSensorHeight, 2) * (3 * (d / 2) - absoluteSensorHeight) * 2;\n    \n    volume = convertOutput((cylinderVolume + headsVolume) / 1000);\n}\n\nfunction calculateHEllipse() {\n    h = convertInput(sizeMeasure.height, tankDimensionUnits);\n    l = convertInput(sizeMeasure.length, tankDimensionUnits);\n    w = convertInput(sizeMeasure.width, tankDimensionUnits);\n    var ellipseSegment = (h * w / 4) * (java.lang.Math.acos(1 - 2 * absoluteSensorHeight / h) -\n        (1 - 2 * absoluteSensorHeight / h) * java.lang.Math.sqrt(4 * absoluteSensorHeight / h - 4 * java.lang.Math.pow(absoluteSensorHeight, 2) / (h * h)));\n        \n    volume = convertOutput((ellipseSegment * l) / 1000);\n}\n\nfunction convertInput(value, dimensionUnits) {\n    if (dimensionUnits == imperial.dimension.inches) {\n        return value * 2.54;\n    } else if (dimensionUnits == imperial.dimension.feets) {\n        return value * 30.48;\n    } else if (dimensionUnits == metric.dimension.milimeters) {\n        return value / 10;\n    } else if (dimensionUnits == metric.dimension.centimeters) {\n        return value;\n    } else if (dimensionUnits == metric.dimension.meters) {\n        return value * 100;\n    } \n}\n    \nfunction convertOutput(value) {\n    if (tankCapacityOutput == imperial.output.gallons) {\n        return value * 0.264172;\n    } else if (tankCapacityOutput == imperial.output.cubicIn) {\n        return value * 61.0237;\n    } else if (tankCapacityOutput == imperial.output.cubicFt) {\n        return value * 0.0353147;\n    } else if (tankCapacityOutput == metric.output.liters) {\n        return value;\n    } else if (tankCapacityOutput == metric.output.cubicMm) {\n        return value * 1000000;\n    } else if (tankCapacityOutput == metric.output.cubicCm) {\n        return value * 1000;\n    } else if (tankCapacityOutput == metric.output.cubicM) {\n        return value * 0.001;\n    } \n}\n\nfuelLevel = ((volume / tankCapacity) * 100);\n\nmsg.fuelLevel = toFixed(parseFloat(fuelLevel), 2);\n\nreturn {msg: msg, metadata: metadata, msgType: msgType};"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 53,
          "layoutY": 265
        },
        "type": "org.thingsboard.rule.engine.filter.TbMsgTypeFilterNode",
        "name": "If post telemetry",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "messageTypes": [
            "POST_TELEMETRY_REQUEST"
          ]
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 398,
          "layoutY": 268
        },
        "type": "org.thingsboard.rule.engine.filter.TbCheckMessageNode",
        "name": "If fuelHeight exists",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "messageNames": [
            "fuelHeight"
          ],
          "metadataNames": [],
          "checkAllKeys": true
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 355,
          "layoutY": 613
        },
        "type": "org.thingsboard.rule.engine.flow.TbCheckpointNode",
        "name": "Sequential processing",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "queueName": "SequentialByOriginator"
        },
        "externalId": null
      },
      {
        "additionalInfo": {
          "description": "",
          "layoutX": 735,
          "layoutY": 620
        },
        "type": "org.thingsboard.rule.engine.flow.TbCheckpointNode",
        "name": "Sequential processing",
        "debugMode": false,
        "singletonMode": false,
        "configuration": {
          "queueName": "SequentialByOriginator"
        },
        "externalId": null
      }
    ],
    "connections": [
      {
        "fromIndex": 2,
        "toIndex": 0,
        "type": "Post telemetry"
      },
      {
        "fromIndex": 2,
        "toIndex": 1,
        "type": "Post attributes"
      },
      {
        "fromIndex": 2,
        "toIndex": 3,
        "type": "RPC Request from Device"
      },
      {
        "fromIndex": 2,
        "toIndex": 4,
        "type": "Other"
      },
      {
        "fromIndex": 2,
        "toIndex": 5,
        "type": "RPC Request to Device"
      },
      {
        "fromIndex": 2,
        "toIndex": 16,
        "type": "Alarm Cleared"
      },
      {
        "fromIndex": 2,
        "toIndex": 17,
        "type": "Activity Event"
      },
      {
        "fromIndex": 2,
        "toIndex": 17,
        "type": "Inactivity Event"
      },
      {
        "fromIndex": 6,
        "toIndex": 2,
        "type": "Success"
      },
      {
        "fromIndex": 6,
        "toIndex": 16,
        "type": "Alarm Cleared"
      },
      {
        "fromIndex": 6,
        "toIndex": 16,
        "type": "Alarm Created"
      },
      {
        "fromIndex": 7,
        "toIndex": 10,
        "type": "Success"
      },
      {
        "fromIndex": 8,
        "toIndex": 9,
        "type": "Success"
      },
      {
        "fromIndex": 10,
        "toIndex": 8,
        "type": "Success"
      },
      {
        "fromIndex": 11,
        "toIndex": 8,
        "type": "Success"
      },
      {
        "fromIndex": 12,
        "toIndex": 13,
        "type": "Success"
      },
      {
        "fromIndex": 13,
        "toIndex": 6,
        "type": "Success"
      },
      {
        "fromIndex": 14,
        "toIndex": 6,
        "type": "False"
      },
      {
        "fromIndex": 14,
        "toIndex": 15,
        "type": "True"
      },
      {
        "fromIndex": 15,
        "toIndex": 6,
        "type": "False"
      },
      {
        "fromIndex": 15,
        "toIndex": 12,
        "type": "True"
      },
      {
        "fromIndex": 16,
        "toIndex": 7,
        "type": "Success"
      },
      {
        "fromIndex": 17,
        "toIndex": 11,
        "type": "Success"
      }
    ],
    "ruleChainConnections": null
  }
}