var data = decodeToJson(payload);

var deviceName = data.end_device_ids.device_id;
var deviceType = data.end_device_ids.application_ids.application_id;

// If you want to parse incoming data somehow, you can add your code to this function.
// input: bytes
// expected output:
//  {
//    "attributes": {"attributeKey": "attributeValue"},
//    "telemetry": {"telemetryKey": "telemetryValue"},
//    "constants": {"constantKey": "constantValue"}
//  }
//
// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.
//

function decodeFrmPayload(input) {
    var output = { attributes:{}, telemetry: {}, constants: {} };
    // --- Decoding code --- //

    output.telemetry.HEX_bytes = bytesToHex(input);

    for (var i = 0; i < input.length; ) {
        var channel_id = input[i++];
        var channel_type = input[i++];
        // BATTERY
        if (channel_id === 0x01 && channel_type === 0x75) {
            output.telemetry.battery = input[i];
            i += 1;
        }
        // PIR
        else if (channel_id === 0x03 && channel_type === 0x00) {
            output.telemetry.pir = input[i] === 0 ? "normal" : "trigger";
            i += 1;
        }
        // DAYLIGHT
        else if (channel_id === 0x04 && channel_type === 0x00) {
            output.telemetry.daylight = input[i] === 0 ? "dark" : "light";
            i += 1;
        } else {
            break;
        }
    }

    // --- Decoding code --- //
    return output;
}

// --- attributes, telemetry and constants objects ---
var telemetry = {};
var attributes = {};
var constants = {};
// --- attributes, telemetry and constants objects ---

// --- Timestamp parsing
var dateString = data.uplink_message.received_at;
var timestamp = new Date(dateString).getTime();
if (timestamp == -1) {
    // Specific data parsing for The Things Stack incoming message
    var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;
    var millisecondsEndIndex = dateString.lastIndexOf('+');
    if (millisecondsEndIndex == -1) {
        millisecondsEndIndex = dateString.lastIndexOf('Z');
    }
    if (millisecondsEndIndex == -1) {
        millisecondsEndIndex = dateString.lastIndexOf('-');
    }
    if (millisecondsEndIndex == -1) {
        if (dateString.length >= secondsSeparatorIndex + 3) {
            dateString = dateString.substring(0, secondsSeparatorIndex + 3);
        }
    } else {
        dateString = dateString.substring(0, secondsSeparatorIndex + 3) +
            dateString.substring(millisecondsEndIndex, dateString.length);
    }
    timestamp = new Date(dateString).getTime();
}
// If we cannot parse timestamp - we will use the current timestamp
if (timestamp == -1) {
    timestamp = Date.now();
}
// --- Timestamp parsing

// You can add some keys manually to attributes, telemetry or constants
attributes.f_port = data.uplink_message.f_port;
// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually
attributes.correlation_ids = data.correlation_ids;
telemetry.gateway_id = data.?uplink_message.rx_metadata[0].gateway_ids.gateway_id;
telemetry.gateway_eui = data.?uplink_message.rx_metadata[0].gateway_ids.eui;
constants.dev_eui = data.end_device_ids.dev_eui;

// You can exclude some keys from the result
var excludeFromTelemetryList = ["uplink_token", "gateway_id", "settings", "f_port", "time", "timestamp", "received_at", "network_ids", "eui"];
var excludeFromConstantsList = ["uplink_token", "gateway_id", "f_port", "time", "timestamp", "received_at", "session_key_id"];

// Message parsing
// To avoid paths in the decoded objects we passing false value to function as "pathInKey" argument.
// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.
var telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);
// Parsing constants (Data described in constants section will be saved to attributes only on first income for every device after integration start/restart)
var constantsData = {};
constantsData.putAll(toFlatMap(data.uplink_message.settings, excludeFromConstantsList, false));
constantsData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromConstantsList, false));
constantsData.putAll(toFlatMap(data.end_device_ids, excludeFromConstantsList, false));

// Passing incoming bytes to decodeFrmPayload function, to get custom decoding
var customDecoding = {};
if (data.uplink_message.get("frm_payload") != null) {
  customDecoding = decodeFrmPayload(base64ToBytes(data.uplink_message.frm_payload));
}

// Collecting data to result
if (customDecoding.?telemetry.size() > 0) {
    telemetry.putAll(customDecoding.telemetry);
}

if (customDecoding.?attributes.size() > 0) {
    attributes.putAll(customDecoding.attributes);
}

if (customDecoding.?constants.size() > 0) {
    constants.putAll(customDecoding.constants);
}

telemetry.putAll(telemetryData);
constants.putAll(constantsData);

var result = {
    deviceName: deviceName,
    deviceType: deviceType,
    telemetry: {
        ts: timestamp,
        values: telemetry
    },
    attributes: attributes,
    constants: constants
};

return result;
